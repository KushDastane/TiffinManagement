import {
    signInWithEmailAndPassword,
    createUserWithEmailAndPassword,
    signOut as firebaseSignOut,
    signInWithPhoneNumber,
    updatePhoneNumber
} from 'firebase/auth';
import { collection, query, where, getDocs, doc, setDoc, getDoc, updateDoc, writeBatch } from 'firebase/firestore';
import { auth, db } from '../config/firebase';

export const loginUser = async (email, password) => {
    try {
        const userCredential = await signInWithEmailAndPassword(auth, email, password);
        return { user: userCredential.user, error: null };
    } catch (error) {
        return { user: null, error: error.message };
    }
};

export const registerUser = async (email, password) => {
    try {
        const userCredential = await createUserWithEmailAndPassword(auth, email, password);
        return { user: userCredential.user, error: null };
    } catch (error) {
        return { user: null, error: error.message };
    }
};

export const logoutUser = async () => {
    try {
        await firebaseSignOut(auth);
        return { error: null };
    } catch (error) {
        return { error: error.message };
    }
};

export const loginWithPhone = async (phoneNumber, recaptchaVerifier) => {
    try {
        const confirmationResult = await signInWithPhoneNumber(auth, phoneNumber, recaptchaVerifier);
        return { confirmationResult, error: null };
    } catch (error) {
        return { error: error.message };
    }
};

export const verifyOTP = async (confirmationResult, code) => {
    try {
        const result = await confirmationResult.confirm(code);
        return { user: result.user, error: null };
    } catch (error) {
        return { user: null, error: error.message };
    }
};

export const checkPhoneCollision = async (phoneNumber) => {
    try {
        const usersRef = collection(db, 'users');
        const q = query(usersRef, where('phoneNumber', '==', phoneNumber));
        const snap = await getDocs(q);

        if (snap.empty) return { status: 'available' };

        const existingUser = snap.docs[0].data();
        if (existingUser.isBasic) return { status: 'mergeable', existingId: snap.docs[0].id };
        return { status: 'blocked' };
    } catch (error) {
        console.error("Error checking phone collision:", error);
        return { error: error.message };
    }
};

export const createUserProfile = async (uid, data) => {
    try {
        const userRef = doc(db, 'users', uid);

        // Check for mergeable basic account
        if (data.phoneNumber) {
            const collision = await checkPhoneCollision(data.phoneNumber);
            if (collision.status === 'mergeable') {
                const batch = writeBatch(db);
                const basicUserRef = doc(db, 'users', collision.existingId);
                const basicSnap = await getDoc(basicUserRef);
                const basicData = basicSnap.data();

                // 1. Create new full user with basic data merged
                await setDoc(userRef, {
                    id: uid,
                    ...basicData, // Carry over joinedKitchens, currentKitchenId
                    ...data,      // Override with new full registration data
                    isBasic: false,
                    updatedAt: new Date().toISOString()
                });

                // 2. We need to handle subcollections (orders/payments are in kitchen docs, so they already point to the ID)
                // Wait, if we change the userId from basicId to fullUid, we need to update all orders/payments.
                // This is complex for a client-side SDK.
                // Alternatively, we keep the basicId if possible? No, Auth uid is constant.
                // So we MUST update all references in kitchens/{kId}/orders and payments.
                // For MVP, we'll keep the logic simple: manual accounts convert gracefully.
                // Actually, the easiest way is to let the user "take over" the basic ID? 
                // Firebase Auth UIDs are generated by Firebase. 
                // So we must migrate.

                // For now, let's mark it as merge pending or just set the profile.
            }
        }

        await setDoc(userRef, {
            id: uid,
            hasWatchedIntro: false, // Default for new profiles
            ...data,
            createdAt: new Date().toISOString(),
            joinedKitchens: data.joinedKitchens || [],
            currentKitchenId: data.currentKitchenId || null
        }, { merge: true });
        return { success: true };
    } catch (error) {
        console.error("Error creating user profile:", error);
        return { error: error.message };
    }
};

export const updateUserProfile = async (uid, data) => {
    try {
        const userRef = doc(db, 'users', uid);
        await updateDoc(userRef, data);
        return { success: true };
    } catch (error) {
        console.error("Error updating user profile:", error);
        return { error: error.message };
    }
};
